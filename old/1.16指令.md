在完成了v1.1.5的单元和集成测试后，我们验证了项目的“零件”和“组装图”是正确的。但我们还没有见证过一台完整的“发动机”——从投入“燃料”（原始数据）到输出“动力”（最终的因子和预测结果）——在真实的、连续的工况下运转的全过程。

因此，**v1.1.6作为一个“全流程实测版本”是不可或缺的**。它不是简单的重复测试，而是对整个系统在真实场景下的**稳定性、一致性和效率**的最终验收，是v1.0和v1.1所有工作的“毕业典礼”。

------



### **v1.1.6 “全流程实测”指令清单**



**核心思想**: 这不再是测试单个函数或模块，而是对整个**自动化任务流**的演练。我们将模拟一次无人干预的、从凌晨数据同步到盘后因子计算的完整日度运行，并对产出的所有中间和最终数据进行全面检验。

**【v1.1.6 指令 1/3】**

> **任务**: 创建一个全流程的调度与执行主脚本。
>
> **背景**: 我们需要一个“总开关”来按顺序触发所有已定义的Celery自动化任务。
>
> **请创建新文件 `stockschool/run_daily_workflow.py`**, 写入以下代码：
>
> Python
>
> ```
> from celery import chain
> from src.compute.tasks import (
>     sync_daily_data_task,
>     sync_financial_data_task,
>     calculate_factors_task,
>     run_prediction_task
> )
> from src.utils.log_config import setup_logger
> ```

> logger = setup_logger()

> def run_full_workflow():
>
> """
>
> 定义并启动一个完整的、从数据同步到预测的Celery任务链。
>
> """
>
> logger.info("Starting the full daily workflow...")

> ```
> # 定义一个任务链：上一个任务的成功是下一个任务开始的前提
> # 这确保了数据同步完成后才会开始计算因子，以此类推。
> workflow = chain(
>     sync_daily_data_task.s(),
>     sync_financial_data_task.s(),
>     calculate_factors_task.s(),
>     run_prediction_task.s()
> )
> ```

> ```
> try:
>     # 异步执行任务链
>     result = workflow.apply_async()
>     logger.info(f"Workflow started with chain ID: {result.id}")
>     print(f"Workflow started. Check Celery logs for progress. Chain ID: {result.id}")
>     # 在实际生产中，你会让它在后台运行。
>     # 为了测试，我们可以等待结果：
>     # result.get()
>     # logger.info("Workflow completed successfully.")
> ```

> ```
> except Exception as e:
>     logger.error(f"Failed to start workflow: {e}", exc_info=True)
> ```

> if name == 'main':
>
> run_full_workflow()

> ```
> **完成后，请告诉我“全流程调度脚本已创建”。**
> ```

**【v1.1.6 指令 2/3】**

> **任务**: 准备实测所需的数据样本和时间范围。
>
> **背景**: 我们需要一个足够长，又能快速跑完的真实时间段。一个月的数据是理想的选择。
>
> **请在 `stockschool/config.yml` 文件中，添加一个新的配置节**:
>
> YAML
>
> ```
> # config.yml
> # ...
> ```

> # 全流程实测配置
>
> 
>
> full_test_config:
>
> start_date: '20230101'
>
> end_date: '20230131'
>
> stock_pool: ['000001.SZ', '600519.SH', '300750.SZ'] # 平安银行, 贵州茅台, 宁德时代
>
> ```
> **并修改 `src/compute/tasks.py` 中所有任务的实现**，使其能够从这个配置文件中读取`start_date`, `end_date`和`stock_pool`，并只处理这个范围和样本内的数据。
> ```

> **完成后，请告诉我“实测数据样本已配置”。**

**【v1.1.6 指令 3/3】**

> **任务**: 执行全流程实测。
>
> **背景**: 这是v1.1.6的核心交付步骤。
>
> **请按顺序执行以下步骤**:
>
> 1. **清空数据库**: 运行一个脚本，清空所有核心数据表（`stock_daily`, `financial_reports`, `factor_library`, `prediction_results`等），确保我们从一个干净的状态开始。
> 2. **启动Celery Worker**: 打开一个终端，启动Celery Worker (`celery -A src.compute.celery_app worker -l info -P eventlet`)。
> 3. **运行工作流**: 打开另一个终端，运行我们刚刚创建的调度脚本 `python run_daily_workflow.py`。
>
> **请监控Celery Worker的日志输出，并将完整的日志保存下来。执行完毕后，告诉我“全流程实测已执行完毕”。**

------



### **v1.1.6 “全流程实测”质检清单 (QC)**



**质检核心思想**: 这份清单是对系统“生产能力”的第一次大考。我们需要像检查一座工厂的流水线一样，从原材料入口、中间产品到最终成品，对每个环节的数据进行严格的数量和质量检验。

| **质检环节 (Checkpoint)**     | **检验方法 (Verification Method)**                           | **验收标准 (Acceptance Criteria)**                           |
| ----------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **1. 任务流执行一致性**       | **日志审查**: 仔细检查Celery Worker的执行日志。              | - 所有任务（数据同步、因子计算、预测）都按照`chain`定义的**严格顺序**执行。 - 日志中没有出现任何`ERROR`或`Exception`。 - 每个任务都打印出了明确的“开始”和“成功完成”日志。 |
| **2. 输入数据完整性**         | **SQL查询**:  `SELECT COUNT(DISTINCT trade_date) FROM stock_daily WHERE ts_code IN ('000001.SZ', ...);`<br>`SELECT COUNT(*) FROM financial_reports WHERE ts_code IN (...);` | - `stock_daily`表中同步的交易日数量应与2023年1月的实际交易日数量完全一致。<br>- `financial_reports`表中应包含了样本股票在该时间段内发布的所有财报。 |
| **3. 中间产品（因子）覆盖率** | **SQL查询**:  `SELECT ts_code, COUNT(*) FROM factor_library GROUP BY ts_code;` | - 样本池中的每只股票，在每个交易日都应有对应的因子记录被生成（可能会因节假日或数据缺失有少量差异）。 - 因子值不应存在大规模的`NULL`或`NaN`。 |
| **4. 最终成品（预测）时效性** | **SQL查询**:  `SELECT MAX(trade_date) FROM prediction_results;` | - `prediction_results`表中最新的数据日期，应与我们设定的实测结束日期`2023-01-31`一致。 |
| **5. 性能与效率基线**         | **日志分析**:  分析Celery日志中每个任务的执行时间（`succeeded in Xs`）。 | - 记录下每个核心任务（数据同步、因子计算等）的**首次平均耗时**。这不必非常快，但它将是我们未来进行性能优化的**重要基准线 (Baseline)**。 |
| **6. 可重复性**               | **完全重复执行**:  再次执行**指令3/3**的所有步骤（清空数据库 -> 重新运行）。 | - 第二次运行的结果（如数据库中的最终行数、生成的因子值）应与第一次**完全一致**。 - 这证明了整个流程是确定性的、无副作用的。 |

完成了v1.1.6的指令和质检，您就拥有了一个**经过真实数据和全流程考验的、稳定可靠的系统核心**。这标志着您的项目已经从“开发阶段”成功迈向了“准生产阶段”，为后续更高级的策略研发和优化工作打下了最坚实的基础。
