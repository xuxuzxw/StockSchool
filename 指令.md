### **项目代号：StockSchool - AI辅助构建指令清单**



**核心指令**:

> 你好，AI。我们将共同构建一个名为“StockSchool”的专业量化投研系统。我将为你提供一系列精确、分步的指令。你的任务是严格按照指令创建和修改文件、执行终端命令，并向我报告每一步的完成情况。
>
> 让我们从初始化项目开始。

------

### **技术栈概览**

- **PostgreSQL + TimescaleDB 镜像**: `timescale/timescaledb:latest-pg15`
- **Python 版本**: `3.11`




### **阶段零：项目初始化与环境设置**



**【指令 1/13】**

> **任务**: 创建项目目录结构和核心配置文件。
>
> **请执行以下终端命令**:
>
> Bash
>
> ```
> # 1. 创建主目录和所有子目录
> mkdir -p stockschool/src/{data,compute,strategy,utils,database,tests,monitoring}
> ```

> # 2. 创建空的Python包文件
>
> 
>
> touch stockschool/src/{data,compute,strategy,utils,database,tests,monitoring}/**init**.py

> # 3. 创建核心配置文件
>
> 
>
> touch stockschool/requirements.txt touch stockschool/.env touch stockschool/docker-compose.yml touch stockschool/Dockerfile touch stockschool/README.md
>
> ```
> **完成后，请告诉我“项目结构创建完毕”。**
> ```

------



### **阶段一：数据库与数据模型构建 (地基工程)**



**【指令 2/13】**

> **任务**: 定义项目的依赖项，并创建数据库Schema。
>
> 1. **修改文件 `stockschool/requirements.txt`**, 写入以下内容:
>
>    Plaintext
>
>    ```
>    pandas
>    numpy
>    tushare
>    akshare
>    psycopg2-binary
>    sqlalchemy
>    timescaledb
>    python-dotenv
>    celery
>    redis
>    requests
>    pytest
>    shap
>    mkdocs
>    streamlit
>    mlflow
>    ```
>
> 2. **创建新文件 `stockschool/database_schema.sql`**, 写入以下SQL代码，它定义了我们所有的表结构和索引:
>
>    SQL
>
>    ```
>    -- 启用TimescaleDB扩展 (如果尚未启用)
>    CREATE EXTENSION IF NOT EXISTS timescaledb;
>    ```

> ```
> -- 1. 日线行情表 (Hypertable)
> CREATE TABLE stock_daily (
>     trade_date  DATE        NOT NULL,
>     ts_code     VARCHAR(10) NOT NULL,
>     open        NUMERIC(10, 2),
>     high        NUMERIC(10, 2),
>     low         NUMERIC(10, 2),
>     close       NUMERIC(10, 2),
>     pre_close   NUMERIC(10, 2),
>     vol         BIGINT,
>     amount      NUMERIC(20, 2)
> );
> SELECT create_hypertable('stock_daily', 'trade_date');
> CREATE INDEX idx_stock_daily_ts_code_date ON stock_daily (ts_code, trade_date DESC);
> ```

> ```
> -- 2. 财务报表数据表
> CREATE TABLE financial_reports (
>     ts_code     VARCHAR(10) NOT NULL,
>     ann_date    DATE,
>     end_date    DATE        NOT NULL,
>     revenue     NUMERIC(20, 2),
>     net_profit  NUMERIC(20, 2),
>     total_assets NUMERIC(20, 2),
>     PRIMARY KEY (ts_code, end_date)
> );
> ```

> ````
> -- 3. 行业分类历史追踪表
> CREATE TABLE sw_industry_history (
>     ts_code     VARCHAR(10) NOT NULL,
>     start_date  DATE        NOT NULL,
>     end_date    DATE,
>     l1_code     VARCHAR(20),
>     l1_name     VARCHAR(50),
>     l2_code     VARCHAR(20),
>     l2_name     VARCHAR(50),
>     l3_code     VARCHAR(20),
>     l3_name     VARCHAR(50),
>     PRIMARY KEY (ts_code, start_date)
> );
> ```
> ````
>
> **完成后，请告诉我“项目依赖与数据库Schema定义完毕”。**

**【指令 3/13】**

> **任务**: 配置Docker环境。
>
> 1. **修改文件 `stockschool/Dockerfile`**, 写入以下内容:
>
>    Dockerfile
>
>    ```
>    FROM python:3.9-slim
>    WORKDIR /app
>    COPY requirements.txt .
>    RUN pip install --no-cache-dir -r requirements.txt
>    COPY ./src /app/src
>    CMD ["python", "src/main.py"]
>    ```
>
> 2. **修改文件 `stockschool/docker-compose.yml`**, 写入以下内容:
>
>    YAML
>
>    ```
>    version: '3.8'
>    services:
>      db:
>        image: timescale/timescaledb:latest-pg14
>        volumes:
>          - postgres_data:/var/lib/postgresql/data
>        environment:
>          - POSTGRES_USER=user
>          - POSTGRES_PASSWORD=${DB_PASSWORD}
>          - POSTGRES_DB=stockschool
>        ports:
>          - "5432:5432"
>      redis:
>        image: "redis:alpine"
>      app:
>        build: .
>        depends_on:
>          - db
>          - redis
>        volumes:
>          - ./src:/app/src
>        env_file:
>          - .env
>    volumes:
>      postgres_data:
>    ```
>
> 3. **修改文件 `stockschool/.env`**, 写入以下模板内容 (请提示我稍后手动填写):
>
>    代码段
>
>    ```
>    # 请替换为你的真实信息
>    TUSHARE_TOKEN=YOUR_TUSHARE_TOKEN
>    DB_PASSWORD=your_strong_password
>    ALERT_WEBHOOK=YOUR_WEBHOOK_URL
>    ```
>
> **完成后，请告诉我“Docker环境配置完毕”。**

**【指令 4/13】**

> **任务**: 使用`psql`工具执行SQL脚本，初始化数据库。
>
> **首先，请提示我**：我现在需要手动启动Docker容器 (`docker-compose up -d`) 并填写`.env`文件。
>
> **在我确认完成后，请执行以下`psql`指令**:
>
> Bash
>
> ```
> psql "postgresql://user:your_strong_password@localhost:5432/stockschool" -f "stockschool/database_schema.sql"
> ```
>
> **执行成功后，告诉我“数据库初始化成功”。如果失败，请提供错误信息。**

------



### **阶段二：数据管道实现 (引入活水)**



**【指令 5/13】**

> **任务**: 创建数据库连接和重试工具。
>
> **创建新文件 `stockschool/src/utils/db.py`**, 写入以下代码:
>
> Python
>
> ```
> import os
> from sqlalchemy import create_engine
> from dotenv import load_dotenv
> ```

> load_dotenv()

> def get_db_engine(): db_user = "user" db_password = os.getenv("DB_PASSWORD") db_name = "stockschool" db_host = "db" # 在Docker网络中使用服务名 db_port = "5432"

> ```
> db_uri = f"postgresql://{db_user}:{db_password}@{db_host}:{db_port}/{db_name}"
> engine = create_engine(db_uri)
> return engine
> **创建新文件 `stockschool/src/utils/retry.py`**, 写入以下代码:
> ```

> Python
>
> ```
> import time
> from functools import wraps
> ```

> def idempotent_retry(max_retries=3): def decorator(func): @wraps(func) def wrapper(*args, **kwargs): for i in range(max_retries): try: return func(*args, **kwargs) except Exception as e: print(f"Attempt {i+1} failed for {func.**name**}: {e}") if i == max_retries - 1: raise e time.sleep(2 ** i) return wrapper return decorator
>
> ```
> **完成后，请告诉我“通用工具创建完毕”。**
> ```

**【指令 6/13】**

> **任务**: 编写Tushare数据同步逻辑。
>
> **创建新文件 `stockschool/src/data/tushare_sync.py`**, 写入以下代码:
>
> Python
>
> ```
> import os
> import pandas as pd
> import tushare as ts
> from sqlalchemy import text
> from src.utils.db import get_db_engine
> from src.utils.retry import idempotent_retry
> ```

> class TushareSynchronizer: def **init**(self): self.pro = ts.pro_api(os.getenv("TUSHARE_TOKEN")) self.engine = get_db_engine()

> ```
> @idempotent_retry()
> def get_last_trade_date(self):
>     with self.engine.connect() as conn:
>         result = conn.execute(text("SELECT max(trade_date) FROM stock_daily")).scalar()
>     return result.strftime('%Y%m%d') if result else '20100101'
> ```

> ```
> @idempotent_retry()
> def update_daily_data(self):
>     start_date = self.get_last_trade_date()
>     trade_cal = self.pro.trade_cal(exchange='', start_date=start_date)
>     trade_dates = trade_cal[trade_cal.is_open == 1]['cal_date']
> ```

> ```
>     all_stocks = self.pro.stock_basic(exchange='', list_status='L', fields='ts_code')
> ```

> ```
>     for date in trade_dates:
>         print(f"Syncing daily data for {date}...")
>         df = self.pro.daily(trade_date=date)
>         df.to_sql('stock_daily', self.engine, if_exists='append', index=False)
> ```

> ```
> # 此处可以继续添加更新行业、财报等方法
> ```

> if **name** == '**main**': synchronizer = TushareSynchronizer() synchronizer.update_daily_data()
>
> ```
> **完成后，请告诉我“Tushare同步器已创建”。**
> ```

------



### **阶段三：核心计算引擎实现 (构建大脑)**



**【指令 7/13】**

> **任务**: 实现因子计算和数据质量控制模块。
>
> **创建新文件 `stockschool/src/compute/technical.py`**, 写入以下代码:
>
> Python
>
> ```
> import pandas as pd
> ```

> def calculate_rsi(df: pd.DataFrame, window: int = 14) -> pd.Series: delta = df['close'].diff() gain = delta.where(delta > 0, 0).rolling(window=window).mean() loss = -delta.where(delta < 0, 0).rolling(window=window).mean() rs = gain / loss rsi = 100 - (100 / (1 + rs)) return rsi
>
> ```
> **创建新文件 `stockschool/src/compute/quality.py`**, 写入以下代码:
> ```

> Python
>
> ```
> import pandas as pd
> ```

> def detect_outliers(data: pd.DataFrame, column: str): # 优先使用前向填充 filled = data[column].ffill()

> ```
> # 如果还有缺失，使用行业均值填充 (假设data中已有'industry'列)
> if filled.isnull().any():
>     industry_mean = data.groupby('industry')[column].transform('mean')
>     filled.fillna(industry_mean, inplace=True)
> ```

> ```
> # 3-sigma原则检测
> mean = filled.mean()
> std_dev = filled.std()
> outliers = (filled - mean).abs() > 3 * std_dev
> return outliers
> **完成后，请告诉我“因子计算与数据质量模块已创建”。**
> ```

**【指令 8/13】**

> **任务**: 创建Celery任务队列配置。
>
> **创建新文件 `stockschool/src/compute/celery_app.py`**, 写入以下代码:
>
> Python
>
> ```
> from celery import Celery
> ```

> app = Celery( 'stockschool_tasks', broker='redis://redis:6379/0', backend='redis://redis:6379/0', include=['src.compute.tasks'] )

> app.conf.update( task_serializer='json', accept_content=['json'], result_serializer='json', timezone='Asia/Shanghai', enable_utc=True, )
>
> ```
> **创建新文件 `stockschool/src/compute/tasks.py`**, 写入以下代码:
> ```

> Python
>
> ```
> from .celery_app import app
> from .technical import calculate_rsi
> # 此处可以导入更多因子计算函数
> ```

> @app.task def task_calculate_rsi(stock_data_json): # 实际应用中会从数据库获取数据 # 这里用json做示例 import pandas as pd df = pd.read_json(stock_data_json) rsi_series = calculate_rsi(df) return rsi_series.to_json()
>
> ```
> **完成后，请告诉我“Celery任务队列配置完毕”。**
> ```

**【指令 9/13】**

> **任务**: 实现特征商店的初步结构。
>
> **创建新文件 `stockschool/src/features/store.py`**, 写入以下代码:
>
> Python
>
> ```
> import json
> from src.utils.db import get_db_engine
> ```

> class FeatureRegistry: def **init**(self): self.engine = get_db_engine() self._create_table_if_not_exists()

> ```
> def _create_table_if_not_exists(self):
>     # 简化版，实际应在schema.sql中定义
>     # ...
>     pass
> ```

> ```
> def register_feature(self, name, sql_template, sources):
>     # 简化版注册逻辑
>     print(f"Feature '{name}' registered with sources: {sources}")
> ```

> if **name** == '**main**': registry = FeatureRegistry() registry.register_feature( name='RSI_14', sql_template='SELECT calculate_rsi(close, 14) FROM stock_daily WHERE ts_code = %s', sources=json.dumps(['stock_daily']) )
>
> ```
> **完成后，请告诉我“特征商店初步结构已创建”。**
> ```

------



### **阶段四：策略与智能化实现 (赋予智慧)**



**【指令 10/13】**

> **任务**: 建立策略评估和模型解释模块。
>
> **创建新文件 `stockschool/src/strategy/evaluate.py`**, 写入以下代码:
>
> Python
>
> ```
> import numpy as np
> ```

> def calculate_sharpe_ratio(returns, periods=252): return np.sqrt(periods) * (returns.mean() / returns.std())

> def calculate_max_drawdown(returns_series): cum_returns = (1 + returns_series).cumprod() peak = cum_returns.expanding(min_periods=1).max() drawdown = (cum_returns/peak) - 1 return drawdown.min()
>
> ```
> **创建新文件 `stockschool/src/strategy/explain.py`**, 写入以下代码:
> ```

> Python
>
> ```
> # 这是一个示例，需要安装lightgbm和shap
> # import shap
> # import lightgbm as lgb
> # from sklearn.model_selection import train_test_split
> ```

> def explain_model_with_shap(model, X_test): # explainer = shap.TreeExplainer(model) # shap_values = explainer.shap_values(X_test) # shap.summary_plot(shap_values, X_test, plot_type="bar") print("SHAP plot would be generated here.")
>
> ```
> **完成后，请告诉我“策略评估与模型解释模块已创建”。**
> ```

**【指令 11/13】**

> **任务**: 创建日志和告警系统。
>
> **创建新文件 `stockschool/src/utils/log_config.py`**, 写入以下代码:
>
> Python
>
> ```
> import logging
> from logging.handlers import RotatingFileHandler
> ```

> def setup_logger(): logger = logging.getLogger('stockschool') logger.setLevel(logging.INFO)

> ```
> # 文件日志
> file_handler = RotatingFileHandler('stockschool.log', maxBytes=10485760, backupCount=5)
> formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
> file_handler.setFormatter(formatter)
> logger.addHandler(file_handler)
> ```

> ```
> # 控制台日志
> stream_handler = logging.StreamHandler()
> stream_handler.setFormatter(formatter)
> logger.addHandler(stream_handler)
> ```

> ```
> return logger
> **创建新文件 `stockschool/src/monitoring/alert.py`**, 写入以下代码:
> ```

> Python
>
> ```
> import os
> import requests
> ```

> def send_alert(message): webhook_url = os.getenv('ALERT_WEBHOOK') if webhook_url: try: requests.post(webhook_url, json={'text': f"[StockSchool Alert]: {message}"}) except Exception as e: print(f"Failed to send alert: {e}") else: print(f"[ALERT]: {message}")
>
> ```
> **完成后，请告诉我“日志与告警系统已创建”。**
> ```

------



### **阶段五：整合与文档化 (项目收尾)**



**【指令 12/13】**

> **任务**: 创建主入口文件和测试文件。
>
> **创建新文件 `stockschool/src/main.py`**, 写入以下代码:
>
> Python
>
> ```
> from src.utils.log_config import setup_logger
> from src.data.tushare_sync import TushareSynchronizer
> from src.monitoring.alert import send_alert
> ```

> logger = setup_logger()

> def main(): logger.info("StockSchool system starting...") try: # 1. 同步数据 logger.info("Starting data synchronization...") synchronizer = TushareSynchronizer() synchronizer.update_daily_data() logger.info("Data synchronization finished.")

> ```
>     # 2. 触发因子计算 (后续通过Celery实现)
>     logger.info("Factor calculation would be triggered here.")
> ```

> ```
>     # 3. 执行策略模型 (后续实现)
>     logger.info("Strategy execution would happen here.")
> ```

> ```
>     logger.info("StockSchool run completed successfully.")
>     send_alert("Daily run completed successfully.")
> ```

> ```
> except Exception as e:
>     logger.error(f"An error occurred during the run: {e}", exc_info=True)
>     send_alert(f"FATAL: Daily run failed with error: {e}")
> ```

> if **name** == '**main**': main()

> ```
> **创建新文件 `stockschool/src/tests/test_technical.py`**, 写入以下代码:
> ```

> Python
>
> ```
> import pytest
> import pandas as pd
> from src.compute.technical import calculate_rsi
> ```

> def test_rsi_calculation(): data = pd.DataFrame({'close': [10, 12, 11, 13, 14, 15, 14, 16, 17, 18, 15, 14]}) rsi = calculate_rsi(data, window=6) assert not rsi.isnull().all() assert (rsi.iloc[-1] >= 0) and (rsi.iloc[-1] <= 100)
>
> ```
> **完成后，请告诉我“主入口与测试文件已创建”。**
> ```

**【指令 13/13】**

> **任务**: 最终检查与运行。
>
> **现在，请按顺序执行以下终端命令**:
>
> Bash
>
> ```
> # 1. 安装所有依赖
> pip install -r stockschool/requirements.txt
> ```

> # 2. 运行单元测试
>
> 
>
> pytest stockschool/src/tests/

> # 3. 运行主程序
>
> 
>
> python stockschool/src/main.py
>
> ```
> **请向我报告每一步的输出。如果所有步骤都成功，我们的初步构建就完成了！**
> ```
